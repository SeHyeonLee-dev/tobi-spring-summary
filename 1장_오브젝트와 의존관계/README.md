1장에서는 스프링을 왜 쓰는지에 대해 집중하는 것이 좋다.

1.1 초난감 DAO
DB와의 연동을 통해 User 데이터를 다루고 싶을 때, User 클래스, UserDao 클래스를 만들고 Main 클래스에서 UserDao의 오브젝트를 생성해 테스트해볼 수 있다.
그런데 이렇게 DAO를 개발했다면 개발팀에서 바로 쫓겨날 수도 있는 한심한 코드이다. 이를 스프링 스타일의 코드로 개선해보자. (스프링을 사용하지는 않는다)
그리고 굳이 잘 작동하는데 왜 이 DAO 코드를 개선해야 하는지에 대해 생각해보면서 답을 찾아나가보자.

1.2 DAO의 분리

1.2.1 관심사의 분리
객체지향 기술은 객체를 최대한 실제 세계에 가깝게 표현할 수 있다. 그리고 객체들을 자유롭고 편리하게 변경, 발전, 확장시킬 수 있다는 데 의미가 있다.
개발자는 변화에 대비해야 한다. 동일한 기능을 가진 코드라도 어떤 사람은 5분만에 코드를 수정하고, 어떤 사람은 5시간이 걸린다.
5분만에 코드를 수정할 수 있는 개발자가 되기 위해선, 관심사의 분리에 대해 아는 것이 중요하다. 그러면 여러 코드를 수정할 필요 없이 한 부분의 코드만 수정하면 기능을 수정할 수 있기 때문이다.

예시 UserDao의 관심사항

1. DB와의 커넥션, 더 세분화하면 어떤 DB를 쓰고, 어떤 드라이버를 사용할 것이고, 어떤 로그인 정보를 쓰는데 그 커넥션을 생성하는 방법은 또 어떤 것이다 이런 식으로 분류할 수도 있다.
2. 사용자 등록을 위해 DB에 보낼 SQL 문장을 담을 Statement를 실행하는 것
3. 작업이 끝나면 사용한 리소스인 Statement와 Connection 오브젝트를 닫아줘서 소중한 공유 리소스를 시스템에 돌려주는 것

1.3 DAO의 확장
UserDao를 상속을 통해 NUserDao와 DUserdao로 나눈다면 UserDao를 수정하던가, 서브클래스를 수정하던가 해서 독립적으로 기능을 수정할 수 있다. 그러나 상속에는 여러가지 단점이 있다.
클래스를 분리하면서도 서로 연관성을 줄이기 위한 좋은 해결책은 인터페이스를 도입하는 것이다.
인터페이스는 어떤 일을 하겠다는 기능만 정의해놓은 것이다. 어떻게 하겠다는 구현 방법은 나타나 있지 않다.
예를 들어 UserDao에서 DB 커넥션 연결 기능을 분리하려면 ConnectionMaker 인터페이스르 정의하고, makeConnection() 메서드를 정의하자.
이 인터페이스를 사용하는 UserDao 입장에서 ConnectionMaker 인터페이스 타입의 오브젝트라면 어떤 클래스로 만들어졌든지 상관없이 makeConnection() 메서드를 호출하기만 하면 Connection 타입의 오브젝트를 만들어서 돌려줄 것이라고 기대할 수 있다.

```java
public class UserDao {
    private ConnectionWorker connectionMaker; // 인터페이스를 통해 접근

    public UserDao() {
        connectionMaker = new DConnectionMaker(); // 여기에 클래스 이름이 나오는 문제가 있다.
    }

    public void add(User user) throws ClassNotFoundException, SQLException {
        Connection c = connectionMaker.makeConnection(); // 클래스가 바뀐다고 해도 메서드 이름이 변경될 일이 없다.
        ...
    }

}
```

하지만 UserDao 클래스 코드에 클래스 이름을 적어야 하는 부분이 남아있어서, 어떤 구현 클래스를 사용할지는 결국 수정해줘야 한다는 문제가 있다.
